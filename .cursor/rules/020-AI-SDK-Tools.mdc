---
description: AI SDK Tool Implementation Patterns
globs: *tool*
alwaysApply: false
---

# AI SDK Tool Implementation Guidelines

## Implemented Tools

The following tools have been implemented in Phase 1:

1. **Semantic Retrieval Tool** (`semanticRetrieval.ts`) - Vector-based semantic search across knowledge graph nodes
2. **Graph Node Extraction Tool** (`extractGraphNodes.ts`) - Extracts entities, concepts, and relationships from conversation messages

## Tool Structure Pattern

Follow this consistent pattern for all AI SDK tools:

```typescript
import { z } from 'zod';
import { getNeo4jDriver, neo4j } from '../../neo4j/driver';
import { serializeNeo4j } from '../../neo4j/serializer';

export const toolName = {
  description: "Clear description of what the tool does",
  parameters: z.object({
    // Define parameters with Zod schema
    param1: z.string().describe("Description of parameter 1"),
    param2: z.number().optional().describe("Description of parameter 2"),
    // Add more parameters as needed
  }),
  execute: async function({ param1, param2 }) {
    // Get Neo4j session directly
    const session = getNeo4jDriver().session({ defaultAccessMode: neo4j.session.READ }); // or WRITE
    
    try {
      // Implement tool logic
      // Execute Neo4j queries
      // Process results
      
      return {
        // Return structured results
      };
    } catch (error) {
      console.error(`Tool execution failed: ${(error as Error).message}`, error);
      throw new Error(`Failed to execute tool: ${(error as Error).message}`);
    } finally {
      await session.close(); // Always close the session
    }
  }
};
```

## Parameter Validation

Use Zod schemas for parameter validation with proper descriptions:

```typescript
parameters: z.object({
  // String parameters
  queryText: z.string().describe("The text query to find relevant information"),
  
  // Optional parameters with defaults
  limit: z.number().int().min(1).max(50).default(10)
    .describe("Maximum number of results to return"),
  
  // Enum parameters
  nodeTypes: z.array(
    z.enum(["Thought", "ReasoningChain", "Person", "Concept", "Entity", "Proposition"])
  ).optional().describe("Types of nodes to search (defaults to all)"),
  
  // Enum with specific values
  extractionDepth: z.enum(["minimal", "standard", "deep"]).default("standard")
    .describe("Level of detail for extraction: minimal (core entities only), standard (entities, concepts, basic relationships), deep (all node types and relationships)"),
  
  // Array parameters
  messages: z.array(z.object({
    id: z.string(),
    role: z.enum(["user", "assistant", "system"]),
    content: z.string().optional(),
    parts: z.array(z.any()).optional()
  }))
});
```

## Semantic Retrieval Tool

The semanticRetrieval tool uses vector embeddings to find semantically similar nodes in the knowledge graph:

```typescript
// 1. Get embedding for query text
const queryEmbedding = await getEmbeddingForText(queryText);

// 2. Build query for each node type and union results
const nodeQueries = validNodeTypes.map(nodeType => {
  const indexName = NODE_TYPE_TO_INDEX[nodeType];
  
  return `
    CALL db.index.vector.queryNodes("${indexName}", $limit, $embedding)
    YIELD node, score
    RETURN node, score, "${nodeType}" AS nodeType
  `;
});

// 3. Execute combined query with UNION ALL
const query = nodeQueries.join("\nUNION ALL\n") + "\nORDER BY score DESC LIMIT $finalLimit";

const result = await session.run(query, {
  embedding: queryEmbedding,
  limit: neo4j.int(Math.ceil(limit / validNodeTypes.length)), // Split limit across types
  finalLimit: neo4j.int(limit) // Final limit after union
});

// 4. Process results with type-specific handling
return result.records.map(record => {
  const node = record.get('node');
  const score = record.get('score');
  const nodeType = record.get('nodeType');
  
  // Base properties all nodes should have
  const baseProps = {
    id: node.properties.id,
    name: node.properties.name,
    nodeType: nodeType,
    similarityScore: score
  };
  
  // Add type-specific properties based on node type
  switch(nodeType) {
    case "Thought":
      return {
        ...baseProps,
        thoughtContent: properties.thoughtContent,
        confidence: properties.confidence
      };
    // Additional case handlers for other node types
  }
});
```

## Graph Node Extraction Tool

The extractGraphNodes tool uses LLM to extract entities and relationships from text:

```typescript
// 1. Prepare conversation context for LLM analysis
const conversationText = prepareConversationText(messages);

// 2. Extract reasoning chains from reasoning tokens if available
const reasoningChains = extractReasoningChains(messages);

// 3. Use LLM to extract nodes based on schema
const systemPrompt = `
Extract entities from the conversation according to this knowledge graph schema:
- Entity: Physical objects, people, locations (id, name, type, description)
- Concept: Abstract ideas and categories (id, name, definition, domain)
- Thought: Subjective interpretations or analyses (id, name, thoughtContent, confidence)
...

Format your response as a valid JSON object with "nodes" and "relationships" arrays.
`;

const response = await openai.chat.completions.create({
  model: "gpt-4o",
  messages: [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: conversationText }
  ]
});

// 4. Parse and process extracted data
const extractedNodes = JSON.parse(extractedJson);

// 5. Save nodes and relationships to Neo4j
const session = getNeo4jDriver().session({ defaultAccessMode: neo4j.session.WRITE });
try {
  for (const node of extractedNodes.nodes) {
    const nodeType = node.type;
    const { type, ...nodeProperties } = { ...node };
    
    await session.run(`
      MERGE (n:${nodeType} {id: $id})
      SET n += $properties
      RETURN n
    `, { id: node.id, properties: nodeProperties });
  }
  
  // Create relationships
  for (const rel of extractedNodes.relationships) {
    await session.run(`
      MATCH (source {id: $sourceId})
      MATCH (target {id: $targetId})
      MERGE (source)-[r:${rel.type}]->(target)
      RETURN r
    `, { sourceId: rel.source, targetId: rel.target });
  }
} finally {
  await session.close();
}
```

## Error Handling

Implement consistent error handling in all tools:

```typescript
try {
  // Tool implementation
} catch (error) {
  // 1. Log the error with context
  console.error(`Error in ${toolName}: ${(error as Error).message}`, {
    parameters: { param1, param2 },
    stack: (error as Error).stack
  });
  
  // 2. Throw a user-friendly error with specific Neo4j error codes
  if ((error as any).code === 'Neo.ClientError.Schema.ConstraintValidationFailed') {
    throw new Error('This entity already exists in the database');
  } else if ((error as any).code?.startsWith('Neo.ClientError')) {
    throw new Error(`Database error: ${(error as Error).message}`);
  } else {
    throw new Error(`Failed to execute tool: ${(error as Error).message}`);
  }
} finally {
  // 3. Always close resources
  await session.close();
}
```

## Future Tools (Phase 2)

The following tools are planned for Phase 2 implementation:

1. **Person Centrality Tool** - Analyze network centrality metrics for Person nodes
2. **Community Detection Tool** - Identify communities in the knowledge graph
3. **Bridging Concepts Tool** - Find concepts that connect different domains
4. **Concept Neighborhood Tool** - Explore the neighborhood of a concept
5. **Reasoning Chain Exploration Tool** - Analyze reasoning chains and their steps
6. **Concept-Reasoning Connection Tool** - Find connections between concepts and reasoning